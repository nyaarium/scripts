#!/usr/bin/env node

import { spawn } from "node:child_process";
import { writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { z } from "zod";

// Schema definitions for the GitHub issue data
const AuthorSchema = z.object({
	id: z.string(),
	is_bot: z.boolean().optional(),
	login: z.string(),
	name: z.string().nullable().optional(),
});

const AssigneeSchema = z.object({
	id: z.string(),
	login: z.string(),
	name: z.string().nullable().optional(),
});

const LabelSchema = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string().nullable().optional(),
	color: z.string(),
});

const CommentSchema = z.object({
	id: z.string(),
	author: AuthorSchema,
	body: z.string(),
	createdAt: z.string(),
	updatedAt: z.string().nullable().optional(),
});

const IssueSchema = z.object({
	number: z.number(),
	title: z.string(),
	body: z.string().nullable(),
	state: z.string(),
	stateReason: z.string().nullable().optional(),
	author: AuthorSchema,
	assignees: z.array(AssigneeSchema),
	labels: z.array(LabelSchema),
	comments: z.array(CommentSchema),
	createdAt: z.string(),
	updatedAt: z.string(),
	closedAt: z.string().nullable(),
});

function printUsage() {
	console.log("");
	console.log(
		"Usage: github-fetch-issue [<repo>] [<issue-id>] [--state <state>] [--limit <limit>] [--output-path <output-path>]",
	);
	console.log("");
	console.log("  repo: Repository in owner/repo format (ex: microsoft/vscode)");
	console.log("  issue-id: The issue number (numeric, optional - if not provided, fetches a list)");
	console.log("  --state: Filter by state: open, closed, or all (default: all, only used when fetching list)");
	console.log("  --limit: Maximum number of issues to fetch (default: 20, only used when fetching list)");
	console.log("  --output-path: Optional path to write JSON output");
	console.log("");
}

function parseArgs() {
	const args = process.argv.slice(2);

	let repo = undefined;
	let issueId = undefined;
	let state = "all";
	let limit = 20;
	let outputPath = undefined;

	// Parse arguments
	let i = 0;
	while (i < args.length) {
		const arg = args[i];

		if (arg === "--output-path") {
			// Handle --output-path flag
			if (i + 1 >= args.length) {
				console.error("Error: --output-path requires a value");
				printUsage();
				process.exit(1);
			}
			outputPath = args[i + 1];
			i += 2;
		} else if (arg === "--state") {
			// Handle --state flag
			if (i + 1 >= args.length) {
				console.error("Error: --state requires a value");
				printUsage();
				process.exit(1);
			}
			const stateValue = args[i + 1];
			if (!["open", "closed", "all"].includes(stateValue)) {
				console.error("Error: --state must be one of: open, closed, all");
				printUsage();
				process.exit(1);
			}
			state = stateValue;
			i += 2;
		} else if (arg === "--limit") {
			// Handle --limit flag
			if (i + 1 >= args.length) {
				console.error("Error: --limit requires a value");
				printUsage();
				process.exit(1);
			}
			const limitValue = parseInt(args[i + 1]);
			if (isNaN(limitValue) || limitValue <= 0) {
				console.error("Error: --limit must be a positive number");
				printUsage();
				process.exit(1);
			}
			limit = limitValue;
			i += 2;
		} else if (arg.includes("/")) {
			// This looks like a repo
			if (repo !== undefined) {
				console.error("Error: Multiple repositories specified");
				printUsage();
				process.exit(1);
			}
			// Validate repo format (must have exactly one slash)
			const slashCount = (arg.match(/\//g) || []).length;
			if (slashCount !== 1) {
				console.error(
					"Error: Repository must be in owner/repo format with exactly one slash (ex: microsoft/vscode)",
				);
				printUsage();
				process.exit(1);
			}
			repo = arg;
			i++;
		} else if (/^\d+$/.test(arg)) {
			// This looks like a numeric issue ID
			if (issueId !== undefined) {
				console.error("Error: Multiple issue IDs specified");
				printUsage();
				process.exit(1);
			}
			issueId = arg;
			i++;
		} else {
			console.error(`Error: Unrecognized argument: ${arg}`);
			printUsage();
			process.exit(1);
		}
	}

	return { repo, issueId, state, limit, outputPath };
}

async function fetchIssue(repo, issueId) {
	return new Promise((resolve, reject) => {
		const cmdArgs = [
			"issue",
			"view",
			issueId,
			"--json",
			"number,title,body,state,stateReason,author,assignees,labels,comments,createdAt,updatedAt,closedAt",
		];

		if (repo) {
			cmdArgs.splice(2, 0, "--repo", repo);
		}

		const child = spawn("gh", cmdArgs, {
			stdio: ["ignore", "pipe", "pipe"],
		});

		let stdout = "";
		let stderr = "";

		child.stdout.on("data", (data) => {
			stdout += data.toString();
		});

		child.stderr.on("data", (data) => {
			stderr += data.toString();
		});

		child.on("close", (code) => {
			if (code === 0) {
				try {
					const rawData = JSON.parse(stdout);
					const validatedData = IssueSchema.parse(rawData);

					const transformedData = {
						number: validatedData.number,
						title: validatedData.title,
						body: validatedData.body,
						state: validatedData.state,
						stateReason: validatedData.stateReason || null,
						author: validatedData.author.name || validatedData.author.login,
						assignees: validatedData.assignees
							.map((assignee) => assignee.name || assignee.login)
							.sort()
							.join(", "),
						labels: validatedData.labels.map((label) => label.name),
						comments: validatedData.comments,
						createdAt: validatedData.createdAt,
						updatedAt: validatedData.updatedAt,
						closedAt: validatedData.closedAt,
					};

					resolve(transformedData);
				} catch (error) {
					reject(new Error(`Failed to parse GitHub CLI output: ${error}`));
				}
			} else {
				reject(new Error(`GitHub CLI failed with code ${code}: ${stderr}`));
			}
		});

		child.on("error", (error) => {
			reject(new Error(`Failed to execute GitHub CLI: ${error.message}`));
		});
	});
}

async function fetchIssues(repo, state, limit) {
	return new Promise((resolve, reject) => {
		const cmdArgs = [
			"issue",
			"list",
			"--state",
			state,
			"--limit",
			limit.toString(),
			"--json",
			"number,title,body,state,stateReason,author,assignees,labels,comments,createdAt,updatedAt,closedAt,isPinned",
		];

		if (repo) {
			cmdArgs.splice(2, 0, "--repo", repo);
		}

		const child = spawn("gh", cmdArgs, {
			stdio: ["ignore", "pipe", "pipe"],
		});

		let stdout = "";
		let stderr = "";

		child.stdout.on("data", (data) => {
			stdout += data.toString();
		});

		child.stderr.on("data", (data) => {
			stderr += data.toString();
		});

		child.on("close", (code) => {
			if (code === 0) {
				try {
					const rawData = JSON.parse(stdout);
					const validatedData = z.array(IssueSchema).parse(rawData);

					const transformedData = validatedData.map((issue) => ({
						number: issue.number,
						title: issue.title,
						body: issue.body,
						state: issue.state,
						stateReason: issue.stateReason || null,
						author: issue.author.name || issue.author.login,
						assignees: issue.assignees.map((assignee) => assignee.name || assignee.login),
						labels: issue.labels.map((label) => label.name),
						comments: issue.comments,
						createdAt: issue.createdAt,
						updatedAt: issue.updatedAt,
						closedAt: issue.closedAt,
						isPinned: issue.isPinned || false,
					}));

					resolve(transformedData);
				} catch (error) {
					reject(new Error(`Failed to parse GitHub CLI output: ${error}`));
				}
			} else {
				reject(new Error(`GitHub CLI failed with code ${code}: ${stderr}`));
			}
		});

		child.on("error", (error) => {
			reject(new Error(`Failed to execute GitHub CLI: ${error.message}`));
		});
	});
}

async function main() {
	try {
		const { repo, issueId, state, limit, outputPath } = parseArgs();

		let data;
		if (issueId) {
			// Fetch single issue
			console.log(`Fetching issue ${issueId}${repo ? ` from ${repo}` : ""}...`);
			data = await fetchIssue(repo, issueId);
		} else {
			// Fetch list of issues
			console.log(`Fetching ${state} issues${repo ? ` from ${repo}` : ""} (limit: ${limit})...`);
			data = await fetchIssues(repo, state, limit);
		}

		if (outputPath) {
			// Write to file and output path info
			const outputPathAbs = resolve(outputPath);
			writeFileSync(outputPathAbs, JSON.stringify(data, null, 2));

			const outputInfo = {
				outputPath: outputPath,
				outputPathAbs: outputPathAbs,
			};
			console.log(JSON.stringify(outputInfo, null, 2));
		} else {
			// Output the transformed data as JSON
			console.log(JSON.stringify(data, null, 2));
		}
	} catch (error) {
		console.error("Error:", error.message);
		process.exit(1);
	}
}

main();
