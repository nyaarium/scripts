#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { spawn } from "node:child_process";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { z } from "zod";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));

const mcpServer = new McpServer({
	name: "scripts-mcp",
	version: "0.1.0",
});

mcpServer.registerTool(
	"treeMd",
	{
		title: "tree-md",
		description: "Render a directory or Markdown file tree using the local tree-md script.",
		inputSchema: {
			paths: z
				.array(z.string())
				.nonempty()
				.describe("One or more absolute or relative paths to scan (directories or .md files)."),
		},
	},
	async ({ paths }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "tree-md");

			const child = spawn(cmdPath, paths, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `tree-md exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [{ type: "text", text: `Failed to run tree-md: ${err.message}` }],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubFetchCommit",
	{
		title: "github-fetch-commit",
		description: "Fetch GitHub commit data using the local github-fetch-commit script.",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			commitHash: z.string().describe("The commit hash to fetch (full or short)."),
			outputPath: z
				.string()
				.optional()
				.describe(
					"Optional path to write JSON output (relative or absolute). If provided, returns path info instead of full data.",
				),
		},
	},
	async ({ repo, commitHash, outputPath }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-fetch-commit");

			// Build arguments array - order doesn't matter for the new parser
			let args = [];

			// Add repo if provided (must contain exactly one slash)
			if (repo) {
				args.push(repo);
			}

			// Add commitHash (must be hex string)
			args.push(commitHash);

			// Add output path if provided (with --output-path flag)
			if (outputPath) {
				args.push("--output-path", outputPath);
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-fetch-commit exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-fetch-commit: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubFetchPr",
	{
		title: "github-fetch-pr",
		description:
			"Fetch GitHub pull request data using the local github-fetch-pr script. By default, commit details are not fetched to keep output size manageable. Recommended to first use fetchFiles=false to check the number of commits. Then use fetchFiles=true if <10 commits.",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			prId: z.string().describe("The pull request number to fetch."),
			fetchFiles: z
				.boolean()
				.optional()
				.default(false)
				.describe(
					"Whether to fetch detailed file information for every commit. Recommended for PRs with <10 commits.",
				),
			outputPath: z
				.string()
				.optional()
				.describe(
					"Optional path to write JSON output (relative or absolute). If provided, returns path info instead of full data.",
				),
		},
	},
	async ({ repo, prId, fetchFiles, outputPath }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-fetch-pr");

			let args = [];

			if (repo) {
				args.push(repo);
			}

			args.push(prId);

			if (fetchFiles) {
				args.push("--fetch-files");
			}

			if (outputPath) {
				args.push("--output-path", outputPath);
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-fetch-pr exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-fetch-pr: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

async function main() {
	const transport = new StdioServerTransport();
	await mcpServer.connect(transport);
}

main().catch((error) => {
	console.error("Server error:", error);
	process.exit(1);
});
