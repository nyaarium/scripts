#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { spawn } from "node:child_process";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { z } from "zod";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));

const mcpServer = new McpServer({
	name: "scripts-mcp",
	version: "0.1.0",
});

mcpServer.registerTool(
	"treeMd",
	{
		title: "tree-md",
		description: "Render a directory or Markdown file tree using the local tree-md script.",
		inputSchema: {
			paths: z
				.array(z.string())
				.nonempty()
				.describe("One or more absolute or relative paths to scan (directories or .md files)."),
		},
	},
	async ({ paths }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "tree-md");

			const child = spawn(cmdPath, paths, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `tree-md exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [{ type: "text", text: `Failed to run tree-md: ${err.message}` }],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubFetchPr",
	{
		title: "github-fetch-pr",
		description: "Fetch GitHub pull request data using the local github-fetch-pr script.",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			prId: z.string().describe("The pull request number to fetch."),
		},
	},
	async ({ repo, prId }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-fetch-pr");

			const args = repo ? [repo, prId] : [prId];
			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-fetch-pr exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-fetch-pr: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

async function main() {
	const transport = new StdioServerTransport();
	await mcpServer.connect(transport);
}

main().catch((error) => {
	console.error("Server error:", error);
	process.exit(1);
});
