#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import dotenv from "dotenv";
import { spawn } from "node:child_process";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { z } from "zod";
import { toolsCursorAgent } from "./manage-agent.js";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));

dotenv.config({
	path: path.join(scriptDir, ".env"),
});

const mcpServer = new McpServer({
	name: "scripts-mcp",
	version: "0.1.0",
});

// Register CursorAgent tools
toolsCursorAgent.forEach((tool) => {
	mcpServer.registerTool(
		tool.name,
		{
			title: tool.title,
			description: tool.description,
			inputSchema: tool.schema.shape,
		},
		async (...args) => {
			try {
				const result = await tool.handler(...args);
				return {
					content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
				};
			} catch (error) {
				return {
					content: [{ type: "text", text: `Error ${tool.operation}: ${error.message}` }],
					isError: true,
				};
			}
		},
	);
});

mcpServer.registerTool(
	"treeMd",
	{
		title: "tree-md",
		description: "Render a directory or Markdown file tree using the local tree-md script.",
		inputSchema: {
			paths: z
				.array(z.string())
				.nonempty()
				.describe("One or more absolute or relative paths to scan (directories or .md files)."),
		},
	},
	async ({ paths }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "tree-md.js");

			const child = spawn(cmdPath, paths, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `tree-md exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [{ type: "text", text: `Failed to run tree-md: ${err.message}` }],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubFetchCommit",
	{
		title: "github-fetch-commit",
		description: "Fetch GitHub commit data using the local github-fetch-commit script.",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			commitHash: z.string().describe("The commit hash to fetch (full or short)."),
			outputPath: z
				.string()
				.optional()
				.describe(
					"Optional path to write JSON output (relative or absolute). If provided, returns path info instead of full data.",
				),
		},
	},
	async ({ repo, commitHash, outputPath }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-fetch-commit.js");

			// Build arguments array - order doesn't matter for the new parser
			let args = [];

			// Add repo if provided (must contain exactly one slash)
			if (repo) {
				args.push(repo);
			}

			// Add commitHash (must be hex string)
			args.push(commitHash);

			// Add output path if provided (with --output-path flag)
			if (outputPath) {
				args.push("--output-path", outputPath);
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-fetch-commit exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-fetch-commit: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubFetchPr",
	{
		title: "github-fetch-pr",
		description:
			"Fetch GitHub pull requests using the local github-fetch-pr script. If prId is provided, fetches a single PR. If not provided, fetches a list of PRs. By default, commit details are not fetched to keep output size manageable. Recommended to first use fetchFiles=false to check the number of commits. Then use fetchFiles=true if <10 commits.",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			prId: z
				.string()
				.optional()
				.describe("The pull request number to fetch. If not provided, fetches a list of PRs."),
			state: z
				.enum(["open", "closed", "merged", "all"])
				.optional()
				.default("open")
				.describe("Filter by PR state: open, closed, merged, or all (only used when fetching list)."),
			limit: z
				.number()
				.int()
				.min(1)
				.max(100)
				.optional()
				.default(20)
				.describe("Maximum number of PRs to fetch (1-100, only used when fetching list)."),
			fetchFiles: z
				.boolean()
				.optional()
				.default(false)
				.describe(
					"Whether to fetch detailed file information for every commit. Recommended for PRs with <10 commits.",
				),
			outputPath: z
				.string()
				.optional()
				.describe(
					"Optional path to write JSON output (relative or absolute). If provided, returns path info instead of full data.",
				),
		},
	},
	async ({ repo, prId, state, limit, fetchFiles, outputPath }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-fetch-pr.js");

			let args = [];

			if (repo) {
				args.push(repo);
			}

			if (prId) {
				args.push(prId);
			} else {
				// Only add state and limit when fetching list
				args.push("--state", state);
				args.push("--limit", limit.toString());
			}

			if (fetchFiles) {
				args.push("--fetch-files");
			}

			if (outputPath) {
				args.push("--output-path", outputPath);
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-fetch-pr exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-fetch-pr: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubFetchIssue",
	{
		title: "github-fetch-issue",
		description:
			"Fetch GitHub issues using the local github-fetch-issue script. If issueId is provided, fetches a single issue. If not provided, fetches a list of issues. Returns detailed information including comments.",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			issueId: z
				.string()
				.optional()
				.describe("The issue number to fetch. If not provided, fetches a list of issues."),
			state: z
				.enum(["open", "closed", "all"])
				.optional()
				.default("all")
				.describe("Filter by issue state: open, closed, or all (only used when fetching list)."),
			limit: z
				.number()
				.int()
				.min(1)
				.max(100)
				.optional()
				.default(20)
				.describe("Maximum number of issues to fetch (1-100, only used when fetching list)."),
			outputPath: z
				.string()
				.optional()
				.describe(
					"Optional path to write JSON output (relative or absolute). If provided, returns path info instead of full data.",
				),
		},
	},
	async ({ repo, issueId, state, limit, outputPath }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-fetch-issue.js");

			let args = [];

			if (repo) {
				args.push(repo);
			}

			if (issueId) {
				args.push(issueId);
			} else {
				// Only add state and limit when fetching list
				args.push("--state", state);
				args.push("--limit", limit.toString());
			}

			if (outputPath) {
				args.push("--output-path", outputPath);
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-fetch-issue exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-fetch-issue: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubApprovePr",
	{
		title: "github-approve-pr",
		description:
			"Approve and optionally merge GitHub pull requests using the local github-approve-pr script. Supports both count mode (-n) and range mode (-r).",
		inputSchema: {
			repo: z
				.string()
				.optional()
				.describe(
					"Repository in owner/repo format (ex: microsoft/vscode). If not provided, uses current repository.",
				),
			prNumbers: z
				.array(z.string())
				.nonempty()
				.describe("Array of PR numbers to approve (e.g., ['123', '456'])."),
			merge: z
				.boolean()
				.optional()
				.default(false)
				.describe("Whether to merge the PR after approval (auto-merge if enabled, manual merge otherwise)."),
		},
	},
	async ({ repo, prNumbers, merge }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-approve-pr.js");

			let args = [];

			if (repo) {
				args.push(repo);
			}

			// Add PR numbers - if single number, add directly; if multiple, add as JSON array
			if (prNumbers.length === 1) {
				args.push(prNumbers[0]);
			} else {
				args.push(JSON.stringify(prNumbers));
			}

			if (merge) {
				args.push("--merge");
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-approve-pr exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-approve-pr: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

mcpServer.registerTool(
	"githubGitLog",
	{
		title: "github-git-log",
		description:
			"Fetch structured git log data using the local github-git-log script. Supports both count mode (-n) and range mode (-r).",
		inputSchema: {
			count: z
				.number()
				.int()
				.min(1)
				.max(10000)
				.optional()
				.describe("Number of log entries to fetch (requires -n flag)."),
			range: z.string().optional().describe("Git range (single hash or hash..hash range, requires -r flag)."),
			outputPath: z
				.string()
				.optional()
				.describe(
					"Optional path to write JSON output (relative or absolute). If provided, returns path info instead of full data.",
				),
		},
	},
	async ({ count, range, outputPath }) => {
		return await new Promise((resolve) => {
			const cmdPath = path.join(scriptDir, "github-git-log.js");

			let args = [];

			// Add count or range (mutually exclusive)
			if (count !== undefined && range !== undefined) {
				resolve({
					content: [
						{
							type: "text",
							text: "Error: Cannot specify both count and range",
						},
					],
					isError: true,
				});
				return;
			}

			if (count !== undefined) {
				args.push("-n", count.toString());
			} else if (range !== undefined) {
				args.push("-r", range);
			} else {
				resolve({
					content: [
						{
							type: "text",
							text: "Error: Either count or range is required",
						},
					],
					isError: true,
				});
				return;
			}

			if (outputPath) {
				args.push("--output-path", outputPath);
			}

			const child = spawn(cmdPath, args, {
				stdio: ["ignore", "pipe", "pipe"],
			});
			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});
			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});
			child.on("close", (code) => {
				if (code === 0) {
					resolve({
						content: [{ type: "text", text: stdout || "(no output)" }],
					});
				} else {
					resolve({
						content: [
							{
								type: "text",
								text: stderr || `github-git-log exited with code ${code}`,
							},
						],
						isError: true,
					});
				}
			});
			child.on("error", (err) => {
				resolve({
					content: [
						{
							type: "text",
							text: `Failed to run github-git-log: ${err.message}`,
						},
					],
					isError: true,
				});
			});
		});
	},
);

async function main() {
	const transport = new StdioServerTransport();
	await mcpServer.connect(transport);
}

main().catch((error) => {
	console.error("Server error:", error);
	process.exit(1);
});
